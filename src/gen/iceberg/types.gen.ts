// This file is auto-generated by @hey-api/openapi-ts

export type AddPartitionSpecUpdate = BaseUpdate & {
    action: 'add-spec';
    spec: PartitionSpec;
};

export type action = 'add-spec';

export type AddSchemaUpdate = BaseUpdate & {
    action: 'add-schema';
    schema: Schema;
    /**
     * The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.
     */
    'last-column-id'?: number;
};

export type action2 = 'add-schema';

export type AddSnapshotUpdate = BaseUpdate & {
    action: 'add-snapshot';
    snapshot: Snapshot;
};

export type action3 = 'add-snapshot';

export type AddSortOrderUpdate = BaseUpdate & {
    action: 'add-sort-order';
    'sort-order': SortOrder;
};

export type action4 = 'add-sort-order';

export type AddViewVersionUpdate = BaseUpdate & {
    action: 'add-view-version';
    'view-version': ViewVersion;
};

export type action5 = 'add-view-version';

export type AndOrExpression = {
    type: ExpressionType;
    left: Expression;
    right: Expression;
};

/**
 * The table must not already exist; used for create transactions
 */
export type AssertCreate = TableRequirement & {
    type: 'assert-create';
};

export type type = 'assert-create';

/**
 * The table's current schema id must match the requirement's `current-schema-id`
 */
export type AssertCurrentSchemaId = TableRequirement & {
    type: 'assert-current-schema-id';
    'current-schema-id': number;
};

export type type2 = 'assert-current-schema-id';

/**
 * The table's default sort order id must match the requirement's `default-sort-order-id`
 */
export type AssertDefaultSortOrderId = TableRequirement & {
    type: 'assert-default-sort-order-id';
    'default-sort-order-id': number;
};

export type type3 = 'assert-default-sort-order-id';

/**
 * The table's default spec id must match the requirement's `default-spec-id`
 */
export type AssertDefaultSpecId = TableRequirement & {
    type: 'assert-default-spec-id';
    'default-spec-id': number;
};

export type type4 = 'assert-default-spec-id';

/**
 * The table's last assigned column id must match the requirement's `last-assigned-field-id`
 */
export type AssertLastAssignedFieldId = TableRequirement & {
    type: 'assert-last-assigned-field-id';
    'last-assigned-field-id': number;
};

export type type5 = 'assert-last-assigned-field-id';

/**
 * The table's last assigned partition id must match the requirement's `last-assigned-partition-id`
 */
export type AssertLastAssignedPartitionId = TableRequirement & {
    type: 'assert-last-assigned-partition-id';
    'last-assigned-partition-id': number;
};

export type type6 = 'assert-last-assigned-partition-id';

/**
 * The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`; if `snapshot-id` is `null` or missing, the ref must not already exist
 */
export type AssertRefSnapshotId = TableRequirement & {
    type: 'assert-ref-snapshot-id';
    ref: string;
    'snapshot-id': number;
};

export type type7 = 'assert-ref-snapshot-id';

/**
 * The table UUID must match the requirement's `uuid`
 */
export type AssertTableUUID = TableRequirement & {
    type: 'assert-table-uuid';
    uuid: string;
};

export type type8 = 'assert-table-uuid';

/**
 * The view UUID must match the requirement's `uuid`
 */
export type AssertViewUUID = ViewRequirement & {
    type: 'assert-view-uuid';
    uuid: string;
};

export type type9 = 'assert-view-uuid';

/**
 * Assigning a UUID to a table/view should only be done when creating the table/view. It is not safe to re-assign the UUID if a table/view already has a UUID assigned
 */
export type AssignUUIDUpdate = BaseUpdate & {
    action: 'assign-uuid';
    uuid: string;
};

export type action6 = 'assign-uuid';

export type BaseUpdate = {
    action: string;
};

/**
 * Binary type values are stored and serialized as an uppercase hexadecimal string
 */
export type BinaryTypeValue = string;

export type BlobMetadata = {
    type: string;
    'snapshot-id': number;
    'sequence-number': number;
    fields: Array<(number)>;
    properties?: {
        [key: string]: unknown;
    };
};

export type BooleanTypeValue = boolean;

/**
 * Server-provided configuration for the catalog.
 */
export type CatalogConfig = {
    /**
     * Properties that should be used to override client configuration; applied after defaults and client configuration.
     */
    overrides: {
        [key: string]: (string);
    };
    /**
     * Properties that should be used as default configuration; applied before client configuration.
     */
    defaults: {
        [key: string]: (string);
    };
};

export type CommitReport = {
    'table-name': string;
    'snapshot-id': number;
    'sequence-number': number;
    operation: string;
    metrics: Metrics;
    metadata?: {
        [key: string]: (string);
    };
};

export type CommitTableRequest = {
    /**
     * Table identifier to update; must be present for CommitTransactionRequest
     */
    identifier?: TableIdentifier;
    requirements: Array<TableRequirement>;
    updates: Array<TableUpdate>;
};

export type CommitTableResponse = {
    'metadata-location': string;
    metadata: TableMetadata;
};

export type CommitTransactionRequest = {
    'table-changes': Array<CommitTableRequest>;
};

export type CommitViewRequest = {
    /**
     * View identifier to update
     */
    identifier?: TableIdentifier;
    requirements?: Array<ViewRequirement>;
    updates: Array<ViewUpdate>;
};

export type ContentFile = {
    content: string;
    'file-path': string;
    'file-format': FileFormat;
    'spec-id': number;
    /**
     * A list of partition field values ordered based on the fields of the partition spec specified by the `spec-id`
     */
    partition?: Array<PrimitiveTypeValue>;
    /**
     * Total file size in bytes
     */
    'file-size-in-bytes': number;
    /**
     * Number of records in the file
     */
    'record-count': number;
    /**
     * Encryption key metadata blob
     */
    'key-metadata'?: (BinaryTypeValue);
    /**
     * List of splittable offsets
     */
    'split-offsets'?: Array<(number)>;
    'sort-order-id'?: number;
};

export type CounterResult = {
    unit: string;
    value: number;
};

export type CountMap = {
    /**
     * List of integer column ids for each corresponding value
     */
    keys?: Array<IntegerTypeValue>;
    /**
     * List of Long values, matched to 'keys' by index
     */
    values?: Array<LongTypeValue>;
};

export type CreateNamespaceRequest = {
    namespace: Namespace;
    /**
     * Configured string to string map of properties for the namespace
     */
    properties?: {
        [key: string]: (string);
    };
};

export type CreateNamespaceResponse = {
    namespace: Namespace;
    /**
     * Properties stored on the namespace, if supported by the server.
     */
    properties?: {
        [key: string]: (string);
    };
};

export type CreateTableRequest = {
    name: string;
    location?: string;
    schema: Schema;
    'partition-spec'?: PartitionSpec;
    'write-order'?: SortOrder;
    'stage-create'?: boolean;
    properties?: {
        [key: string]: (string);
    };
};

export type CreateViewRequest = {
    name: string;
    location?: string;
    schema: Schema;
    /**
     * The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema
     */
    'view-version': ViewVersion;
    properties: {
        [key: string]: (string);
    };
};

export type DataFile = ContentFile & {
    content: 'data';
    /**
     * Map of column id to total count, including null and NaN
     */
    'column-sizes'?: (CountMap);
    /**
     * Map of column id to null value count
     */
    'value-counts'?: (CountMap);
    /**
     * Map of column id to null value count
     */
    'null-value-counts'?: (CountMap);
    /**
     * Map of column id to number of NaN values in the column
     */
    'nan-value-counts'?: (CountMap);
    /**
     * Map of column id to lower bound primitive type values
     */
    'lower-bounds'?: (ValueMap);
    /**
     * Map of column id to upper bound primitive type values
     */
    'upper-bounds'?: (ValueMap);
};

export type content = 'data';

/**
 * Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format
 */
export type DateTypeValue = string;

/**
 * Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain text, while decimals with a negative scale use scientific notation and the exponent will be equal to the negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2', and with a negative scale is '2E+20'
 */
export type DecimalTypeValue = string;

export type DoubleTypeValue = number;

export type EqualityDeleteFile = ContentFile & {
    content: 'equality-deletes';
    /**
     * List of equality field IDs
     */
    'equality-ids'?: Array<(number)>;
};

export type content2 = 'equality-deletes';

/**
 * JSON error payload returned in a response with further details on the error
 */
export type ErrorModel = {
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Internal type definition of the error
     */
    type: string;
    /**
     * HTTP response code
     */
    code: number;
    stack?: Array<(string)>;
};

export type Expression = AndOrExpression | NotExpression | SetExpression | LiteralExpression | UnaryExpression;

export type ExpressionType = string;

export type FileFormat = 'avro' | 'orc' | 'parquet';

/**
 * Fixed length type values are stored and serialized as an uppercase hexadecimal string preserving the fixed length
 */
export type FixedTypeValue = string;

export type FloatTypeValue = number;

export type GetNamespaceResponse = {
    namespace: Namespace;
    /**
     * Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.
     */
    properties?: {
        [key: string]: (string);
    } | null;
    'namespace-uuid'?: (string) | null;
};

/**
 * JSON wrapper for all error responses (non-2xx)
 */
export type IcebergErrorResponse = {
    error: ErrorModel;
};

export type IntegerTypeValue = number;

export type ListNamespacesResponse = {
    'next-page-token'?: PageToken;
    namespaces?: Array<Namespace>;
    'namespace-uuids'?: Array<(string)> | null;
};

export type ListTablesResponse = {
    'next-page-token'?: PageToken;
    identifiers?: Array<TableIdentifier>;
    'table-uuids'?: Array<(string)> | null;
};

export type ListType = {
    type: 'list';
    'element-id': number;
    element: Type;
    'element-required': boolean;
};

export type type10 = 'list';

export type LiteralExpression = {
    type: ExpressionType;
    term: Term;
    value: {
        [key: string]: unknown;
    };
};

/**
 * Result used when a table is successfully loaded.
 *
 *
 * The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
 * Clients can check whether metadata has changed by comparing metadata locations after the table has been created.
 *
 *
 * The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.
 *
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled
 *
 * ## AWS Configurations
 *
 * The following configurations should be respected when working with tables stored in AWS S3
 * - `client.region`: region to configure client for making requests to AWS
 * - `s3.access-key-id`: id for for credentials that provide access to the data in S3
 * - `s3.secret-access-key`: secret for credentials that provide access to data in S3
 * - `s3.session-token`: if present, this value should be used for as the session token
 * - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification
 *
 */
export type LoadTableResult = {
    /**
     * May be null if the table is staged as part of a transaction
     */
    'metadata-location'?: string;
    metadata: TableMetadata;
    config?: {
        [key: string]: (string);
    };
};

/**
 * Result used when a view is successfully loaded.
 *
 *
 * The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field.
 * Clients can check whether metadata has changed by comparing metadata locations after the view has been created.
 *
 * The `config` map returns view-specific configuration for the view's resources.
 *
 * The following configurations should be respected by clients:
 *
 * ## General Configurations
 *
 * - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled
 *
 */
export type LoadViewResult = {
    'metadata-location': string;
    metadata: ViewMetadata;
    config?: {
        [key: string]: (string);
    };
};

export type LongTypeValue = number;

export type MapType = {
    type: 'map';
    'key-id': number;
    key: Type;
    'value-id': number;
    value: Type;
    'value-required': boolean;
};

export type type11 = 'map';

export type MetadataLog = Array<{
    'metadata-file': string;
    'timestamp-ms': number;
}>;

export type MetricResult = CounterResult | TimerResult;

export type Metrics = {
    [key: string]: MetricResult;
};

/**
 * Reference to one or more levels of a namespace
 */
export type Namespace = Array<(string)>;

export type NotExpression = {
    type: ExpressionType;
    child: Expression;
};

export type NullOrder = 'nulls-first' | 'nulls-last';

/**
 * OAuth2 client credentials request
 *
 * See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
 */
export type OAuthClientCredentialsRequest = {
    grant_type: 'client_credentials';
    scope?: string;
    /**
     * Client ID
     *
     * This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
     */
    client_id: string;
    /**
     * Client secret
     *
     * This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
     */
    client_secret: string;
};

export type grant_type = 'client_credentials';

export type OAuthError = {
    error: 'invalid_request' | 'invalid_client' | 'invalid_grant' | 'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope';
    error_description?: string;
    error_uri?: string;
};

export type error = 'invalid_request' | 'invalid_client' | 'invalid_grant' | 'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope';

/**
 * OAuth2 token exchange request
 *
 * See https://datatracker.ietf.org/doc/html/rfc8693
 */
export type OAuthTokenExchangeRequest = {
    grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange';
    scope?: string;
    requested_token_type?: TokenType;
    /**
     * Subject token for token exchange request
     */
    subject_token: string;
    subject_token_type: TokenType;
    /**
     * Actor token for token exchange request
     */
    actor_token?: string;
    actor_token_type?: TokenType;
};

export type grant_type2 = 'urn:ietf:params:oauth:grant-type:token-exchange';

export type OAuthTokenRequest = OAuthClientCredentialsRequest | OAuthTokenExchangeRequest;

export type OAuthTokenResponse = {
    /**
     * The access token, for client credentials or token exchange
     */
    access_token: string;
    /**
     * Access token type for client credentials or token exchange
     *
     * See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
     */
    token_type: 'bearer' | 'mac' | 'N_A';
    /**
     * Lifetime of the access token in seconds for client credentials or token exchange
     */
    expires_in?: number;
    issued_token_type?: TokenType;
    /**
     * Refresh token for client credentials or token exchange
     */
    refresh_token?: string;
    /**
     * Authorization scope for client credentials or token exchange
     */
    scope?: string;
};

/**
 * Access token type for client credentials or token exchange
 *
 * See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
 */
export type token_type = 'bearer' | 'mac' | 'N_A';

/**
 * An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.
 * Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.
 * Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.
 * Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.
 * Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
 */
export type PageToken = (string) | null;

/**
 * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
 *
 * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
 *
 * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
 *
 */
export type Parameterdata_access = 'vended-credentials' | 'remote-signing';

/**
 * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
 */
export type Parameternamespace = string;

/**
 * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
 */
export type Parameterpage_size = number;

export type Parameterpage_token = PageToken;

/**
 * An optional prefix in the path
 */
export type Parameterprefix = string;

/**
 * A table name
 */
export type Parametertable = string;

/**
 * A view name
 */
export type Parameterview = string;

export type PartitionField = {
    'field-id'?: number;
    'source-id': number;
    name: string;
    transform: Transform;
};

export type PartitionSpec = {
    readonly 'spec-id'?: number;
    fields: Array<PartitionField>;
};

export type PartitionStatisticsFile = {
    'snapshot-id': number;
    'statistics-path': string;
    'file-size-in-bytes': number;
};

export type PositionDeleteFile = ContentFile & {
    content: 'position-deletes';
};

export type content3 = 'position-deletes';

export type PrimitiveType = string;

export type PrimitiveTypeValue = BooleanTypeValue | IntegerTypeValue | LongTypeValue | FloatTypeValue | DoubleTypeValue | DecimalTypeValue | StringTypeValue | UUIDTypeValue | DateTypeValue | TimeTypeValue | TimestampTypeValue | TimestampTzTypeValue | TimestampNanoTypeValue | TimestampTzNanoTypeValue | FixedTypeValue | BinaryTypeValue;

export type Reference = string;

export type RegisterTableRequest = {
    name: string;
    'metadata-location': string;
};

export type RemovePartitionStatisticsUpdate = BaseUpdate & {
    action: 'remove-partition-statistics';
    'snapshot-id': number;
};

export type action7 = 'remove-partition-statistics';

export type RemovePropertiesUpdate = BaseUpdate & {
    action: 'remove-properties';
    removals: Array<(string)>;
};

export type action8 = 'remove-properties';

export type RemoveSnapshotRefUpdate = BaseUpdate & {
    action: 'remove-snapshot-ref';
    'ref-name': string;
};

export type action9 = 'remove-snapshot-ref';

export type RemoveSnapshotsUpdate = BaseUpdate & {
    action: 'remove-snapshots';
    'snapshot-ids': Array<(number)>;
};

export type action10 = 'remove-snapshots';

export type RemoveStatisticsUpdate = BaseUpdate & {
    action: 'remove-statistics';
    'snapshot-id': number;
};

export type action11 = 'remove-statistics';

export type RenameTableRequest = {
    source: TableIdentifier;
    destination: TableIdentifier;
};

export type ReportMetricsRequest = ScanReport | CommitReport | {
    'report-type': string;
};

export type ScanReport = {
    'table-name': string;
    'snapshot-id': number;
    filter: Expression;
    'schema-id': number;
    'projected-field-ids': Array<(number)>;
    'projected-field-names': Array<(string)>;
    metrics: Metrics;
    metadata?: {
        [key: string]: (string);
    };
};

export type Schema = StructType & {
    readonly 'schema-id'?: number;
    'identifier-field-ids'?: Array<(number)>;
};

export type SetCurrentSchemaUpdate = BaseUpdate & {
    action: 'set-current-schema';
    /**
     * Schema ID to set as current, or -1 to set last added schema
     */
    'schema-id': number;
};

export type action12 = 'set-current-schema';

export type SetCurrentViewVersionUpdate = BaseUpdate & {
    action: 'set-current-view-version';
    /**
     * The view version id to set as current, or -1 to set last added view version id
     */
    'view-version-id': number;
};

export type action13 = 'set-current-view-version';

export type SetDefaultSortOrderUpdate = BaseUpdate & {
    action: 'set-default-sort-order';
    /**
     * Sort order ID to set as the default, or -1 to set last added sort order
     */
    'sort-order-id': number;
};

export type action14 = 'set-default-sort-order';

export type SetDefaultSpecUpdate = BaseUpdate & {
    action: 'set-default-spec';
    /**
     * Partition spec ID to set as the default, or -1 to set last added spec
     */
    'spec-id': number;
};

export type action15 = 'set-default-spec';

export type SetExpression = {
    type: ExpressionType;
    term: Term;
    values: Array<{
        [key: string]: unknown;
    }>;
};

export type SetLocationUpdate = BaseUpdate & {
    action: 'set-location';
    location: string;
};

export type action16 = 'set-location';

export type SetPartitionStatisticsUpdate = BaseUpdate & {
    action: 'set-partition-statistics';
    'partition-statistics': PartitionStatisticsFile;
};

export type action17 = 'set-partition-statistics';

export type SetPropertiesUpdate = BaseUpdate & {
    action: 'set-properties';
    updates: {
        [key: string]: (string);
    };
};

export type action18 = 'set-properties';

export type SetSnapshotRefUpdate = BaseUpdate & SnapshotReference & {
    action: 'set-snapshot-ref';
    'ref-name': string;
};

export type action19 = 'set-snapshot-ref';

export type SetStatisticsUpdate = BaseUpdate & {
    action: 'set-statistics';
    'snapshot-id': number;
    statistics: StatisticsFile;
};

export type action20 = 'set-statistics';

export type Snapshot = {
    'snapshot-id': number;
    'parent-snapshot-id'?: number;
    'sequence-number'?: number;
    'timestamp-ms': number;
    /**
     * Location of the snapshot's manifest list file
     */
    'manifest-list': string;
    summary: {
        operation: 'append' | 'replace' | 'overwrite' | 'delete';
        [key: string]: (string) | undefined;
    };
    'schema-id'?: number;
};

export type operation = 'append' | 'replace' | 'overwrite' | 'delete';

export type SnapshotLog = Array<{
    'snapshot-id': number;
    'timestamp-ms': number;
}>;

export type SnapshotReference = {
    type: 'tag' | 'branch';
    'snapshot-id': number;
    'max-ref-age-ms'?: number;
    'max-snapshot-age-ms'?: number;
    'min-snapshots-to-keep'?: number;
};

export type type12 = 'tag' | 'branch';

export type SnapshotReferences = {
    [key: string]: SnapshotReference;
};

export type SortDirection = 'asc' | 'desc';

export type SortField = {
    'source-id': number;
    transform: Transform;
    direction: SortDirection;
    'null-order': NullOrder;
};

export type SortOrder = {
    readonly 'order-id': number;
    fields: Array<SortField>;
};

export type SQLViewRepresentation = {
    type: string;
    sql: string;
    dialect: string;
};

export type StatisticsFile = {
    'snapshot-id': number;
    'statistics-path': string;
    'file-size-in-bytes': number;
    'file-footer-size-in-bytes': number;
    'blob-metadata': Array<BlobMetadata>;
};

export type StringTypeValue = string;

export type StructField = {
    id: number;
    name: string;
    type: Type;
    required: boolean;
    doc?: string;
};

export type StructType = {
    type: 'struct';
    fields: Array<StructField>;
};

export type type13 = 'struct';

export type TableIdentifier = {
    namespace: Namespace;
    name: string;
};

export type TableMetadata = {
    'format-version': number;
    'table-uuid': string;
    location?: string;
    'last-updated-ms'?: number;
    properties?: {
        [key: string]: (string);
    };
    schemas?: Array<Schema>;
    'current-schema-id'?: number;
    'last-column-id'?: number;
    'partition-specs'?: Array<PartitionSpec>;
    'default-spec-id'?: number;
    'last-partition-id'?: number;
    'sort-orders'?: Array<SortOrder>;
    'default-sort-order-id'?: number;
    snapshots?: Array<Snapshot>;
    refs?: SnapshotReferences;
    'current-snapshot-id'?: number;
    'last-sequence-number'?: number;
    'snapshot-log'?: SnapshotLog;
    'metadata-log'?: MetadataLog;
    'statistics-files'?: Array<StatisticsFile>;
    'partition-statistics-files'?: Array<PartitionStatisticsFile>;
};

export type TableRequirement = {
    type: string;
};

export type TableUpdate = AssignUUIDUpdate | UpgradeFormatVersionUpdate | AddSchemaUpdate | SetCurrentSchemaUpdate | AddPartitionSpecUpdate | SetDefaultSpecUpdate | AddSortOrderUpdate | SetDefaultSortOrderUpdate | AddSnapshotUpdate | SetSnapshotRefUpdate | RemoveSnapshotsUpdate | RemoveSnapshotRefUpdate | SetLocationUpdate | SetPropertiesUpdate | RemovePropertiesUpdate | SetStatisticsUpdate | RemoveStatisticsUpdate;

export type Term = Reference | TransformTerm;

export type TimerResult = {
    'time-unit': string;
    count: number;
    'total-duration': number;
};

/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision
 */
export type TimestampNanoTypeValue = string;

/**
 * Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 */
export type TimestampTypeValue = string;

/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond precision, and a timezone offset (+00:00 for UTC)
 */
export type TimestampTzNanoTypeValue = string;

/**
 * TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision, and a timezone offset (+00:00 for UTC)
 */
export type TimestampTzTypeValue = string;

/**
 * Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 */
export type TimeTypeValue = string;

/**
 * Token type identifier, from RFC 8693 Section 3
 *
 * See https://datatracker.ietf.org/doc/html/rfc8693#section-3
 */
export type TokenType = 'urn:ietf:params:oauth:token-type:access_token' | 'urn:ietf:params:oauth:token-type:refresh_token' | 'urn:ietf:params:oauth:token-type:id_token' | 'urn:ietf:params:oauth:token-type:saml1' | 'urn:ietf:params:oauth:token-type:saml2' | 'urn:ietf:params:oauth:token-type:jwt';

export type Transform = string;

export type TransformTerm = {
    type: 'transform';
    transform: Transform;
    term: Reference;
};

export type type14 = 'transform';

export type Type = PrimitiveType | StructType | ListType | MapType;

export type UnaryExpression = {
    type: ExpressionType;
    term: Term;
    value: {
        [key: string]: unknown;
    };
};

export type UpdateNamespacePropertiesRequest = {
    removals?: Array<(string)>;
    updates?: {
        [key: string]: (string);
    };
};

export type UpdateNamespacePropertiesResponse = {
    /**
     * List of property keys that were added or updated
     */
    updated: Array<(string)>;
    /**
     * List of properties that were removed
     */
    removed: Array<(string)>;
    /**
     * List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.
     */
    missing?: Array<(string)> | null;
};

export type UpgradeFormatVersionUpdate = BaseUpdate & {
    action: 'upgrade-format-version';
    'format-version': number;
};

export type action21 = 'upgrade-format-version';

/**
 * UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified by RFC-4122
 */
export type UUIDTypeValue = string;

export type ValueMap = {
    /**
     * List of integer column ids for each corresponding value
     */
    keys?: Array<IntegerTypeValue>;
    /**
     * List of primitive type values, matched to 'keys' by index
     */
    values?: Array<PrimitiveTypeValue>;
};

export type ViewHistoryEntry = {
    'version-id': number;
    'timestamp-ms': number;
};

export type ViewMetadata = {
    'view-uuid': string;
    'format-version': number;
    location: string;
    'current-version-id': number;
    versions: Array<ViewVersion>;
    'version-log': Array<ViewHistoryEntry>;
    schemas: Array<Schema>;
    properties?: {
        [key: string]: (string);
    };
};

export type ViewRepresentation = SQLViewRepresentation;

export type ViewRequirement = {
    type: string;
};

export type ViewUpdate = AssignUUIDUpdate | UpgradeFormatVersionUpdate | AddSchemaUpdate | SetLocationUpdate | SetPropertiesUpdate | RemovePropertiesUpdate | AddViewVersionUpdate | SetCurrentViewVersionUpdate;

export type ViewVersion = {
    'version-id': number;
    'timestamp-ms': number;
    /**
     * Schema ID to set as current, or -1 to set last added schema
     */
    'schema-id': number;
    summary: {
        [key: string]: (string);
    };
    representations: Array<ViewRepresentation>;
    'default-catalog'?: string;
    'default-namespace': Namespace;
};

export type GetConfigData = {
    query?: {
        /**
         * Warehouse location or identifier to request from the service
         */
        warehouse?: string;
    };
};

export type GetConfigResponse = (CatalogConfig);

export type GetConfigError = (IcebergErrorResponse);

export type GetTokenData = {
    body?: OAuthTokenRequest;
};

export type GetTokenResponse = (OAuthTokenResponse);

export type GetTokenError = (OAuthError);

export type ListNamespacesData = {
    path: {
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
    query?: {
        /**
         * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
         */
        pageSize?: number;
        pageToken?: PageToken;
        /**
         * An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (`0x1F`) byte.
         */
        parent?: string;
        /**
         * If true, include the `namespace-uuids` field in the response
         */
        returnUuids?: boolean;
    };
};

export type ListNamespacesResponse2 = (ListNamespacesResponse);

export type ListNamespacesError = (IcebergErrorResponse);

export type CreateNamespaceData = {
    body?: CreateNamespaceRequest;
    path: {
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type CreateNamespaceResponse2 = (CreateNamespaceResponse);

export type CreateNamespaceError = (IcebergErrorResponse | ErrorModel);

export type LoadNamespaceMetadataData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
    query?: {
        /**
         * If true, include the `namespace-uuid` field in the response
         */
        returnUuid?: boolean;
    };
};

export type LoadNamespaceMetadataResponse = (GetNamespaceResponse);

export type LoadNamespaceMetadataError = (IcebergErrorResponse);

export type NamespaceExistsData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type NamespaceExistsResponse = (void);

export type NamespaceExistsError = (IcebergErrorResponse);

export type DropNamespaceData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type DropNamespaceResponse = (void);

export type DropNamespaceError = (IcebergErrorResponse);

export type UpdatePropertiesData = {
    body?: UpdateNamespacePropertiesRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type UpdatePropertiesResponse = (UpdateNamespacePropertiesResponse);

export type UpdatePropertiesError = (IcebergErrorResponse | ErrorModel);

export type ListTablesData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
    query?: {
        /**
         * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
         */
        pageSize?: number;
        pageToken?: PageToken;
        /**
         * If true, include the `table-uuids` field in the response
         */
        returnUuids?: boolean;
    };
};

export type ListTablesResponse2 = (ListTablesResponse);

export type ListTablesError = (IcebergErrorResponse);

export type CreateTableData = {
    body?: CreateTableRequest;
    headers?: {
        /**
         * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
         *
         * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
         *
         * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
         *
         */
        'X-Iceberg-Access-Delegation'?: 'vended-credentials' | 'remote-signing';
    };
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type CreateTableResponse = (LoadTableResult);

export type CreateTableError = (IcebergErrorResponse);

export type RegisterTableData = {
    body?: RegisterTableRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type RegisterTableResponse = (LoadTableResult);

export type RegisterTableError = (IcebergErrorResponse);

export type LoadTableData = {
    headers?: {
        /**
         * Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.
         *
         * Specific properties and handling for `vended-credentials` is documented in the `LoadTableResult` schema section of this spec document.
         *
         * The protocol and specification for `remote-signing` is documented in  the `s3-signer-open-api.yaml` OpenApi spec in the `aws` module.
         *
         */
        'X-Iceberg-Access-Delegation'?: 'vended-credentials' | 'remote-signing';
    };
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A table name
         */
        table: string;
    };
    query?: {
        /**
         * The snapshots to return in the body of the metadata. Setting the value to `all` would return the full set of snapshots currently valid for the table. Setting the value to `refs` would load all snapshots referenced by branches or tags.
         * Default if no param is provided is `all`.
         */
        snapshots?: 'all' | 'refs';
    };
};

export type LoadTableResponse = (LoadTableResult);

export type LoadTableError = (IcebergErrorResponse);

export type UpdateTableData = {
    body?: CommitTableRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A table name
         */
        table: string;
    };
};

export type UpdateTableResponse = (CommitTableResponse);

export type UpdateTableError = (IcebergErrorResponse);

export type DropTableData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A table name
         */
        table: string;
    };
    query?: {
        /**
         * Whether the user requested to purge the underlying table's data and metadata
         */
        purgeRequested?: boolean;
    };
};

export type DropTableResponse = (void);

export type DropTableError = (IcebergErrorResponse);

export type TableExistsData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A table name
         */
        table: string;
    };
};

export type TableExistsResponse = (void);

export type TableExistsError = (IcebergErrorResponse);

export type RenameTableData = {
    /**
     * Current table identifier to rename and new table identifier to rename to
     */
    body: RenameTableRequest;
    path: {
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type RenameTableResponse = (void);

export type RenameTableError = (IcebergErrorResponse | ErrorModel);

export type ReportMetricsData = {
    /**
     * The request containing the metrics report to be sent
     */
    body: ReportMetricsRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A table name
         */
        table: string;
    };
};

export type ReportMetricsResponse = (void);

export type ReportMetricsError = (IcebergErrorResponse);

export type CommitTransactionData = {
    /**
     * Commit updates to multiple tables in an atomic operation
     *
     * A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value.
     *
     * Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
     */
    body: CommitTransactionRequest;
    path: {
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type CommitTransactionResponse = (void);

export type CommitTransactionError = (IcebergErrorResponse);

export type ListViewsData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
    query?: {
        /**
         * For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated `pageSize`.
         */
        pageSize?: number;
        pageToken?: PageToken;
    };
};

export type ListViewsResponse = (ListTablesResponse);

export type ListViewsError = (IcebergErrorResponse | ErrorModel);

export type CreateViewData = {
    body?: CreateViewRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type CreateViewResponse = (LoadViewResult);

export type CreateViewError = (IcebergErrorResponse | ErrorModel);

export type LoadViewData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A view name
         */
        view: string;
    };
};

export type LoadViewResponse = (LoadViewResult);

export type LoadViewError = (IcebergErrorResponse | ErrorModel);

export type ReplaceViewData = {
    body?: CommitViewRequest;
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A view name
         */
        view: string;
    };
};

export type ReplaceViewResponse = (LoadViewResult);

export type ReplaceViewError = (IcebergErrorResponse | ErrorModel);

export type DropViewData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A view name
         */
        view: string;
    };
};

export type DropViewResponse = (void);

export type DropViewError = (IcebergErrorResponse | ErrorModel);

export type ViewExistsData = {
    path: {
        /**
         * A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (`0x1F`) byte.
         */
        namespace: string;
        /**
         * An optional prefix in the path
         */
        prefix: string;
        /**
         * A view name
         */
        view: string;
    };
};

export type ViewExistsResponse = (void);

export type ViewExistsError = (unknown | IcebergErrorResponse);

export type RenameViewData = {
    /**
     * Current view identifier to rename and new view identifier to rename to
     */
    body: RenameTableRequest;
    path: {
        /**
         * An optional prefix in the path
         */
        prefix: string;
    };
};

export type RenameViewResponse = (unknown);

export type RenameViewError = (IcebergErrorResponse | ErrorModel);