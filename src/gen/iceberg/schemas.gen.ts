// This file is auto-generated by @hey-api/openapi-ts

export const ErrorModelSchema = {
    type: 'object',
    description: 'JSON error payload returned in a response with further details on the error',
    required: ['message', 'type', 'code'],
    properties: {
        message: {
            type: 'string',
            description: 'Human-readable error message'
        },
        type: {
            type: 'string',
            description: 'Internal type definition of the error',
            example: 'NoSuchNamespaceException'
        },
        code: {
            type: 'integer',
            minimum: 400,
            maximum: 600,
            description: 'HTTP response code',
            example: 404
        },
        stack: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const CatalogConfigSchema = {
    type: 'object',
    description: 'Server-provided configuration for the catalog.',
    required: ['defaults', 'overrides'],
    properties: {
        overrides: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            },
            description: 'Properties that should be used to override client configuration; applied after defaults and client configuration.'
        },
        defaults: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            },
            description: 'Properties that should be used as default configuration; applied before client configuration.'
        }
    }
} as const;

export const CreateNamespaceRequestSchema = {
    type: 'object',
    required: ['namespace'],
    properties: {
        namespace: {
            '$ref': '#/components/schemas/Namespace'
        },
        properties: {
            type: 'object',
            description: 'Configured string to string map of properties for the namespace',
            example: {
                owner: 'Hank Bendickson'
            },
            default: {},
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const UpdateNamespacePropertiesRequestSchema = {
    type: 'object',
    properties: {
        removals: {
            type: 'array',
            uniqueItems: true,
            items: {
                type: 'string'
            },
            example: ['department', 'access_group']
        },
        updates: {
            type: 'object',
            example: {
                owner: 'Hank Bendickson'
            },
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const RenameTableRequestSchema = {
    type: 'object',
    required: ['source', 'destination'],
    properties: {
        source: {
            '$ref': '#/components/schemas/TableIdentifier'
        },
        destination: {
            '$ref': '#/components/schemas/TableIdentifier'
        }
    }
} as const;

export const NamespaceSchema = {
    description: 'Reference to one or more levels of a namespace',
    type: 'array',
    items: {
        type: 'string'
    },
    example: ['accounting', 'tax'],
    properties: {
        length: {
            type: 'integer'
        }
    }
} as const;

export const PageTokenSchema = {
    description: `An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter \`pageToken\` to the server.
Servers that support pagination should identify the \`pageToken\` parameter and return a \`next-page-token\` in the response if there are more results available.  After the initial request, the value of \`next-page-token\` from each response must be used as the \`pageToken\` parameter value for the next request. The server must return \`null\` value for the \`next-page-token\` in the last response.
Servers that support pagination must return all results in a single response with the value of \`next-page-token\` set to \`null\` if the query parameter \`pageToken\` is not set in the request.
Servers that do not support pagination should ignore the \`pageToken\` parameter and return all results in a single response. The \`next-page-token\` must be omitted from the response.
Clients must interpret either \`null\` or missing response value of \`next-page-token\` as the end of the listing results.`,
    type: 'string',
    nullable: true
} as const;

export const TableIdentifierSchema = {
    type: 'object',
    required: ['namespace', 'name'],
    properties: {
        namespace: {
            '$ref': '#/components/schemas/Namespace'
        },
        name: {
            type: 'string',
            nullable: false
        }
    }
} as const;

export const PrimitiveTypeSchema = {
    type: 'string',
    example: ['long', 'string', 'fixed[16]', 'decimal(10,2)']
} as const;

export const StructFieldSchema = {
    type: 'object',
    required: ['id', 'name', 'type', 'required'],
    properties: {
        id: {
            type: 'integer'
        },
        name: {
            type: 'string'
        },
        type: {
            '$ref': '#/components/schemas/Type'
        },
        required: {
            type: 'boolean'
        },
        doc: {
            type: 'string'
        }
    }
} as const;

export const StructTypeSchema = {
    type: 'object',
    required: ['type', 'fields'],
    properties: {
        type: {
            type: 'string',
            enum: ['struct']
        },
        fields: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/StructField'
            }
        }
    }
} as const;

export const ListTypeSchema = {
    type: 'object',
    required: ['type', 'element-id', 'element', 'element-required'],
    properties: {
        type: {
            type: 'string',
            enum: ['list']
        },
        'element-id': {
            type: 'integer'
        },
        element: {
            '$ref': '#/components/schemas/Type'
        },
        'element-required': {
            type: 'boolean'
        }
    }
} as const;

export const MapTypeSchema = {
    type: 'object',
    required: ['type', 'key-id', 'key', 'value-id', 'value', 'value-required'],
    properties: {
        type: {
            type: 'string',
            enum: ['map']
        },
        'key-id': {
            type: 'integer'
        },
        key: {
            '$ref': '#/components/schemas/Type'
        },
        'value-id': {
            type: 'integer'
        },
        value: {
            '$ref': '#/components/schemas/Type'
        },
        'value-required': {
            type: 'boolean'
        }
    }
} as const;

export const TypeSchema = {
    oneOf: [
        {
            '$ref': '#/components/schemas/PrimitiveType'
        },
        {
            '$ref': '#/components/schemas/StructType'
        },
        {
            '$ref': '#/components/schemas/ListType'
        },
        {
            '$ref': '#/components/schemas/MapType'
        }
    ]
} as const;

export const SchemaSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/StructType'
        },
        {
            type: 'object',
            properties: {
                'schema-id': {
                    type: 'integer',
                    readOnly: true
                },
                'identifier-field-ids': {
                    type: 'array',
                    items: {
                        type: 'integer'
                    }
                }
            }
        }
    ]
} as const;

export const ExpressionSchema = {
    oneOf: [
        {
            '$ref': '#/components/schemas/AndOrExpression'
        },
        {
            '$ref': '#/components/schemas/NotExpression'
        },
        {
            '$ref': '#/components/schemas/SetExpression'
        },
        {
            '$ref': '#/components/schemas/LiteralExpression'
        },
        {
            '$ref': '#/components/schemas/UnaryExpression'
        }
    ]
} as const;

export const ExpressionTypeSchema = {
    type: 'string',
    example: ['eq', 'and', 'or', 'not', 'in', 'not-in', 'lt', 'lt-eq', 'gt', 'gt-eq', 'not-eq', 'starts-with', 'not-starts-with', 'is-null', 'not-null', 'is-nan', 'not-nan']
} as const;

export const AndOrExpressionSchema = {
    type: 'object',
    required: ['type', 'left', 'right'],
    properties: {
        type: {
            '$ref': '#/components/schemas/ExpressionType',
            enum: ['and', 'or']
        },
        left: {
            '$ref': '#/components/schemas/Expression'
        },
        right: {
            '$ref': '#/components/schemas/Expression'
        }
    }
} as const;

export const NotExpressionSchema = {
    type: 'object',
    required: ['type', 'child'],
    properties: {
        type: {
            '$ref': '#/components/schemas/ExpressionType',
            enum: ['not']
        },
        child: {
            '$ref': '#/components/schemas/Expression'
        }
    }
} as const;

export const UnaryExpressionSchema = {
    type: 'object',
    required: ['type', 'term', 'value'],
    properties: {
        type: {
            '$ref': '#/components/schemas/ExpressionType',
            enum: ['is-null', 'not-null', 'is-nan', 'not-nan']
        },
        term: {
            '$ref': '#/components/schemas/Term'
        },
        value: {
            type: 'object'
        }
    }
} as const;

export const LiteralExpressionSchema = {
    type: 'object',
    required: ['type', 'term', 'value'],
    properties: {
        type: {
            '$ref': '#/components/schemas/ExpressionType',
            enum: ['lt', 'lt-eq', 'gt', 'gt-eq', 'eq', 'not-eq', 'starts-with', 'not-starts-with']
        },
        term: {
            '$ref': '#/components/schemas/Term'
        },
        value: {
            type: 'object'
        }
    }
} as const;

export const SetExpressionSchema = {
    type: 'object',
    required: ['type', 'term', 'values'],
    properties: {
        type: {
            '$ref': '#/components/schemas/ExpressionType',
            enum: ['in', 'not-in']
        },
        term: {
            '$ref': '#/components/schemas/Term'
        },
        values: {
            type: 'array',
            items: {
                type: 'object'
            }
        }
    }
} as const;

export const TermSchema = {
    oneOf: [
        {
            '$ref': '#/components/schemas/Reference'
        },
        {
            '$ref': '#/components/schemas/TransformTerm'
        }
    ]
} as const;

export const ReferenceSchema = {
    type: 'string',
    example: ['column-name']
} as const;

export const TransformTermSchema = {
    type: 'object',
    required: ['type', 'transform', 'term'],
    properties: {
        type: {
            type: 'string',
            enum: ['transform']
        },
        transform: {
            '$ref': '#/components/schemas/Transform'
        },
        term: {
            '$ref': '#/components/schemas/Reference'
        }
    }
} as const;

export const TransformSchema = {
    type: 'string',
    example: ['identity', 'year', 'month', 'day', 'hour', 'bucket[256]', 'truncate[16]']
} as const;

export const PartitionFieldSchema = {
    type: 'object',
    required: ['source-id', 'transform', 'name'],
    properties: {
        'field-id': {
            type: 'integer'
        },
        'source-id': {
            type: 'integer'
        },
        name: {
            type: 'string'
        },
        transform: {
            '$ref': '#/components/schemas/Transform'
        }
    }
} as const;

export const PartitionSpecSchema = {
    type: 'object',
    required: ['fields'],
    properties: {
        'spec-id': {
            type: 'integer',
            readOnly: true
        },
        fields: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/PartitionField'
            }
        }
    }
} as const;

export const SortDirectionSchema = {
    type: 'string',
    enum: ['asc', 'desc']
} as const;

export const NullOrderSchema = {
    type: 'string',
    enum: ['nulls-first', 'nulls-last']
} as const;

export const SortFieldSchema = {
    type: 'object',
    required: ['source-id', 'transform', 'direction', 'null-order'],
    properties: {
        'source-id': {
            type: 'integer'
        },
        transform: {
            '$ref': '#/components/schemas/Transform'
        },
        direction: {
            '$ref': '#/components/schemas/SortDirection'
        },
        'null-order': {
            '$ref': '#/components/schemas/NullOrder'
        }
    }
} as const;

export const SortOrderSchema = {
    type: 'object',
    required: ['order-id', 'fields'],
    properties: {
        'order-id': {
            type: 'integer',
            readOnly: true
        },
        fields: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/SortField'
            }
        }
    }
} as const;

export const SnapshotSchema = {
    type: 'object',
    required: ['snapshot-id', 'timestamp-ms', 'manifest-list', 'summary'],
    properties: {
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'parent-snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'sequence-number': {
            type: 'integer',
            format: 'int64'
        },
        'timestamp-ms': {
            type: 'integer',
            format: 'int64'
        },
        'manifest-list': {
            type: 'string',
            description: "Location of the snapshot's manifest list file"
        },
        summary: {
            type: 'object',
            required: ['operation'],
            properties: {
                operation: {
                    type: 'string',
                    enum: ['append', 'replace', 'overwrite', 'delete']
                }
            },
            additionalProperties: {
                type: 'string'
            }
        },
        'schema-id': {
            type: 'integer'
        }
    }
} as const;

export const SnapshotReferenceSchema = {
    type: 'object',
    required: ['type', 'snapshot-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['tag', 'branch']
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'max-ref-age-ms': {
            type: 'integer',
            format: 'int64'
        },
        'max-snapshot-age-ms': {
            type: 'integer',
            format: 'int64'
        },
        'min-snapshots-to-keep': {
            type: 'integer'
        }
    }
} as const;

export const SnapshotReferencesSchema = {
    type: 'object',
    additionalProperties: {
        '$ref': '#/components/schemas/SnapshotReference'
    }
} as const;

export const SnapshotLogSchema = {
    type: 'array',
    items: {
        type: 'object',
        required: ['snapshot-id', 'timestamp-ms'],
        properties: {
            'snapshot-id': {
                type: 'integer',
                format: 'int64'
            },
            'timestamp-ms': {
                type: 'integer',
                format: 'int64'
            }
        }
    }
} as const;

export const MetadataLogSchema = {
    type: 'array',
    items: {
        type: 'object',
        required: ['metadata-file', 'timestamp-ms'],
        properties: {
            'metadata-file': {
                type: 'string'
            },
            'timestamp-ms': {
                type: 'integer',
                format: 'int64'
            }
        }
    }
} as const;

export const TableMetadataSchema = {
    type: 'object',
    required: ['format-version', 'table-uuid'],
    properties: {
        'format-version': {
            type: 'integer',
            minimum: 1,
            maximum: 2
        },
        'table-uuid': {
            type: 'string'
        },
        location: {
            type: 'string'
        },
        'last-updated-ms': {
            type: 'integer',
            format: 'int64'
        },
        properties: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        schemas: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Schema'
            }
        },
        'current-schema-id': {
            type: 'integer'
        },
        'last-column-id': {
            type: 'integer'
        },
        'partition-specs': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/PartitionSpec'
            }
        },
        'default-spec-id': {
            type: 'integer'
        },
        'last-partition-id': {
            type: 'integer'
        },
        'sort-orders': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/SortOrder'
            }
        },
        'default-sort-order-id': {
            type: 'integer'
        },
        snapshots: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Snapshot'
            }
        },
        refs: {
            '$ref': '#/components/schemas/SnapshotReferences'
        },
        'current-snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'last-sequence-number': {
            type: 'integer',
            format: 'int64'
        },
        'snapshot-log': {
            '$ref': '#/components/schemas/SnapshotLog'
        },
        'metadata-log': {
            '$ref': '#/components/schemas/MetadataLog'
        },
        'statistics-files': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/StatisticsFile'
            }
        },
        'partition-statistics-files': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/PartitionStatisticsFile'
            }
        }
    }
} as const;

export const SQLViewRepresentationSchema = {
    type: 'object',
    required: ['type', 'sql', 'dialect'],
    properties: {
        type: {
            type: 'string'
        },
        sql: {
            type: 'string'
        },
        dialect: {
            type: 'string'
        }
    }
} as const;

export const ViewRepresentationSchema = {
    oneOf: [
        {
            '$ref': '#/components/schemas/SQLViewRepresentation'
        }
    ]
} as const;

export const ViewHistoryEntrySchema = {
    type: 'object',
    required: ['version-id', 'timestamp-ms'],
    properties: {
        'version-id': {
            type: 'integer'
        },
        'timestamp-ms': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const ViewVersionSchema = {
    type: 'object',
    required: ['version-id', 'timestamp-ms', 'schema-id', 'summary', 'representations', 'default-namespace'],
    properties: {
        'version-id': {
            type: 'integer'
        },
        'timestamp-ms': {
            type: 'integer',
            format: 'int64'
        },
        'schema-id': {
            type: 'integer',
            description: 'Schema ID to set as current, or -1 to set last added schema'
        },
        summary: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        representations: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ViewRepresentation'
            }
        },
        'default-catalog': {
            type: 'string'
        },
        'default-namespace': {
            '$ref': '#/components/schemas/Namespace'
        }
    }
} as const;

export const ViewMetadataSchema = {
    type: 'object',
    required: ['view-uuid', 'format-version', 'location', 'current-version-id', 'versions', 'version-log', 'schemas'],
    properties: {
        'view-uuid': {
            type: 'string'
        },
        'format-version': {
            type: 'integer',
            minimum: 1,
            maximum: 1
        },
        location: {
            type: 'string'
        },
        'current-version-id': {
            type: 'integer'
        },
        versions: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ViewVersion'
            }
        },
        'version-log': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ViewHistoryEntry'
            }
        },
        schemas: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/Schema'
            }
        },
        properties: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const BaseUpdateSchema = {
    discriminator: {
        propertyName: 'action',
        mapping: {
            'assign-uuid': '#/components/schemas/AssignUUIDUpdate',
            'upgrade-format-version': '#/components/schemas/UpgradeFormatVersionUpdate',
            'add-schema': '#/components/schemas/AddSchemaUpdate',
            'set-current-schema': '#/components/schemas/SetCurrentSchemaUpdate',
            'add-spec': '#/components/schemas/AddPartitionSpecUpdate',
            'set-default-spec': '#/components/schemas/SetDefaultSpecUpdate',
            'add-sort-order': '#/components/schemas/AddSortOrderUpdate',
            'set-default-sort-order': '#/components/schemas/SetDefaultSortOrderUpdate',
            'add-snapshot': '#/components/schemas/AddSnapshotUpdate',
            'set-snapshot-ref': '#/components/schemas/SetSnapshotRefUpdate',
            'remove-snapshots': '#/components/schemas/RemoveSnapshotsUpdate',
            'remove-snapshot-ref': '#/components/schemas/RemoveSnapshotRefUpdate',
            'set-location': '#/components/schemas/SetLocationUpdate',
            'set-properties': '#/components/schemas/SetPropertiesUpdate',
            'remove-properties': '#/components/schemas/RemovePropertiesUpdate',
            'add-view-version': '#/components/schemas/AddViewVersionUpdate',
            'set-current-view-version': '#/components/schemas/SetCurrentViewVersionUpdate',
            'set-statistics': '#/components/schemas/SetStatisticsUpdate',
            'remove-statistics': '#/components/schemas/RemoveStatisticsUpdate',
            'set-partition-statistics': '#/components/schemas/SetPartitionStatisticsUpdate',
            'remove-partition-statistics': '#/components/schemas/RemovePartitionStatisticsUpdate'
        }
    },
    type: 'object',
    required: ['action'],
    properties: {
        action: {
            type: 'string'
        }
    }
} as const;

export const AssignUUIDUpdateSchema = {
    description: 'Assigning a UUID to a table/view should only be done when creating the table/view. It is not safe to re-assign the UUID if a table/view already has a UUID assigned',
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'uuid'],
    properties: {
        action: {
            type: 'string',
            enum: ['assign-uuid']
        },
        uuid: {
            type: 'string'
        }
    }
} as const;

export const UpgradeFormatVersionUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'format-version'],
    properties: {
        action: {
            type: 'string',
            enum: ['upgrade-format-version']
        },
        'format-version': {
            type: 'integer'
        }
    }
} as const;

export const AddSchemaUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'schema'],
    properties: {
        action: {
            type: 'string',
            enum: ['add-schema']
        },
        schema: {
            '$ref': '#/components/schemas/Schema'
        },
        'last-column-id': {
            type: 'integer',
            description: 'The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.'
        }
    }
} as const;

export const SetCurrentSchemaUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'schema-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-current-schema']
        },
        'schema-id': {
            type: 'integer',
            description: 'Schema ID to set as current, or -1 to set last added schema'
        }
    }
} as const;

export const AddPartitionSpecUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'spec'],
    properties: {
        action: {
            type: 'string',
            enum: ['add-spec']
        },
        spec: {
            '$ref': '#/components/schemas/PartitionSpec'
        }
    }
} as const;

export const SetDefaultSpecUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'spec-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-default-spec']
        },
        'spec-id': {
            type: 'integer',
            description: 'Partition spec ID to set as the default, or -1 to set last added spec'
        }
    }
} as const;

export const AddSortOrderUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'sort-order'],
    properties: {
        action: {
            type: 'string',
            enum: ['add-sort-order']
        },
        'sort-order': {
            '$ref': '#/components/schemas/SortOrder'
        }
    }
} as const;

export const SetDefaultSortOrderUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'sort-order-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-default-sort-order']
        },
        'sort-order-id': {
            type: 'integer',
            description: 'Sort order ID to set as the default, or -1 to set last added sort order'
        }
    }
} as const;

export const AddSnapshotUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'snapshot'],
    properties: {
        action: {
            type: 'string',
            enum: ['add-snapshot']
        },
        snapshot: {
            '$ref': '#/components/schemas/Snapshot'
        }
    }
} as const;

export const SetSnapshotRefUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        },
        {
            '$ref': '#/components/schemas/SnapshotReference'
        }
    ],
    required: ['action', 'ref-name'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-snapshot-ref']
        },
        'ref-name': {
            type: 'string'
        }
    }
} as const;

export const RemoveSnapshotsUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'snapshot-ids'],
    properties: {
        action: {
            type: 'string',
            enum: ['remove-snapshots']
        },
        'snapshot-ids': {
            type: 'array',
            items: {
                type: 'integer',
                format: 'int64'
            }
        }
    }
} as const;

export const RemoveSnapshotRefUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'ref-name'],
    properties: {
        action: {
            type: 'string',
            enum: ['remove-snapshot-ref']
        },
        'ref-name': {
            type: 'string'
        }
    }
} as const;

export const SetLocationUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'location'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-location']
        },
        location: {
            type: 'string'
        }
    }
} as const;

export const SetPropertiesUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'updates'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-properties']
        },
        updates: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const RemovePropertiesUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'removals'],
    properties: {
        action: {
            type: 'string',
            enum: ['remove-properties']
        },
        removals: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const AddViewVersionUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'view-version'],
    properties: {
        action: {
            type: 'string',
            enum: ['add-view-version']
        },
        'view-version': {
            '$ref': '#/components/schemas/ViewVersion'
        }
    }
} as const;

export const SetCurrentViewVersionUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'view-version-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-current-view-version']
        },
        'view-version-id': {
            type: 'integer',
            description: 'The view version id to set as current, or -1 to set last added view version id'
        }
    }
} as const;

export const SetStatisticsUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'snapshot-id', 'statistics'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-statistics']
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        statistics: {
            '$ref': '#/components/schemas/StatisticsFile'
        }
    }
} as const;

export const RemoveStatisticsUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'snapshot-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['remove-statistics']
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const SetPartitionStatisticsUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'partition-statistics'],
    properties: {
        action: {
            type: 'string',
            enum: ['set-partition-statistics']
        },
        'partition-statistics': {
            '$ref': '#/components/schemas/PartitionStatisticsFile'
        }
    }
} as const;

export const RemovePartitionStatisticsUpdateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/BaseUpdate'
        }
    ],
    required: ['action', 'snapshot-id'],
    properties: {
        action: {
            type: 'string',
            enum: ['remove-partition-statistics']
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const TableUpdateSchema = {
    anyOf: [
        {
            '$ref': '#/components/schemas/AssignUUIDUpdate'
        },
        {
            '$ref': '#/components/schemas/UpgradeFormatVersionUpdate'
        },
        {
            '$ref': '#/components/schemas/AddSchemaUpdate'
        },
        {
            '$ref': '#/components/schemas/SetCurrentSchemaUpdate'
        },
        {
            '$ref': '#/components/schemas/AddPartitionSpecUpdate'
        },
        {
            '$ref': '#/components/schemas/SetDefaultSpecUpdate'
        },
        {
            '$ref': '#/components/schemas/AddSortOrderUpdate'
        },
        {
            '$ref': '#/components/schemas/SetDefaultSortOrderUpdate'
        },
        {
            '$ref': '#/components/schemas/AddSnapshotUpdate'
        },
        {
            '$ref': '#/components/schemas/SetSnapshotRefUpdate'
        },
        {
            '$ref': '#/components/schemas/RemoveSnapshotsUpdate'
        },
        {
            '$ref': '#/components/schemas/RemoveSnapshotRefUpdate'
        },
        {
            '$ref': '#/components/schemas/SetLocationUpdate'
        },
        {
            '$ref': '#/components/schemas/SetPropertiesUpdate'
        },
        {
            '$ref': '#/components/schemas/RemovePropertiesUpdate'
        },
        {
            '$ref': '#/components/schemas/SetStatisticsUpdate'
        },
        {
            '$ref': '#/components/schemas/RemoveStatisticsUpdate'
        }
    ]
} as const;

export const ViewUpdateSchema = {
    anyOf: [
        {
            '$ref': '#/components/schemas/AssignUUIDUpdate'
        },
        {
            '$ref': '#/components/schemas/UpgradeFormatVersionUpdate'
        },
        {
            '$ref': '#/components/schemas/AddSchemaUpdate'
        },
        {
            '$ref': '#/components/schemas/SetLocationUpdate'
        },
        {
            '$ref': '#/components/schemas/SetPropertiesUpdate'
        },
        {
            '$ref': '#/components/schemas/RemovePropertiesUpdate'
        },
        {
            '$ref': '#/components/schemas/AddViewVersionUpdate'
        },
        {
            '$ref': '#/components/schemas/SetCurrentViewVersionUpdate'
        }
    ]
} as const;

export const TableRequirementSchema = {
    discriminator: {
        propertyName: 'type',
        mapping: {
            'assert-create': '#/components/schemas/AssertCreate',
            'assert-table-uuid': '#/components/schemas/AssertTableUUID',
            'assert-ref-snapshot-id': '#/components/schemas/AssertRefSnapshotId',
            'assert-last-assigned-field-id': '#/components/schemas/AssertLastAssignedFieldId',
            'assert-current-schema-id': '#/components/schemas/AssertCurrentSchemaId',
            'assert-last-assigned-partition-id': '#/components/schemas/AssertLastAssignedPartitionId',
            'assert-default-spec-id': '#/components/schemas/AssertDefaultSpecId',
            'assert-default-sort-order-id': '#/components/schemas/AssertDefaultSortOrderId'
        }
    },
    type: 'object',
    required: ['type'],
    properties: {
        type: {
            type: 'string'
        }
    }
} as const;

export const AssertCreateSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    type: 'object',
    description: 'The table must not already exist; used for create transactions',
    required: ['type'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-create']
        }
    }
} as const;

export const AssertTableUUIDSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table UUID must match the requirement's `uuid`",
    required: ['type', 'uuid'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-table-uuid']
        },
        uuid: {
            type: 'string'
        }
    }
} as const;

export const AssertRefSnapshotIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`; if `snapshot-id` is `null` or missing, the ref must not already exist",
    required: ['type', 'ref', 'snapshot-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-ref-snapshot-id']
        },
        ref: {
            type: 'string'
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const AssertLastAssignedFieldIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table's last assigned column id must match the requirement's `last-assigned-field-id`",
    required: ['type', 'last-assigned-field-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-last-assigned-field-id']
        },
        'last-assigned-field-id': {
            type: 'integer'
        }
    }
} as const;

export const AssertCurrentSchemaIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table's current schema id must match the requirement's `current-schema-id`",
    required: ['type', 'current-schema-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-current-schema-id']
        },
        'current-schema-id': {
            type: 'integer'
        }
    }
} as const;

export const AssertLastAssignedPartitionIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table's last assigned partition id must match the requirement's `last-assigned-partition-id`",
    required: ['type', 'last-assigned-partition-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-last-assigned-partition-id']
        },
        'last-assigned-partition-id': {
            type: 'integer'
        }
    }
} as const;

export const AssertDefaultSpecIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table's default spec id must match the requirement's `default-spec-id`",
    required: ['type', 'default-spec-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-default-spec-id']
        },
        'default-spec-id': {
            type: 'integer'
        }
    }
} as const;

export const AssertDefaultSortOrderIdSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/TableRequirement'
        }
    ],
    description: "The table's default sort order id must match the requirement's `default-sort-order-id`",
    required: ['type', 'default-sort-order-id'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-default-sort-order-id']
        },
        'default-sort-order-id': {
            type: 'integer'
        }
    }
} as const;

export const ViewRequirementSchema = {
    discriminator: {
        propertyName: 'type',
        mapping: {
            'assert-view-uuid': '#/components/schemas/AssertViewUUID'
        }
    },
    type: 'object',
    required: ['type'],
    properties: {
        type: {
            type: 'string'
        }
    }
} as const;

export const AssertViewUUIDSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/ViewRequirement'
        }
    ],
    description: "The view UUID must match the requirement's `uuid`",
    required: ['type', 'uuid'],
    properties: {
        type: {
            type: 'string',
            enum: ['assert-view-uuid']
        },
        uuid: {
            type: 'string'
        }
    }
} as const;

export const LoadTableResultSchema = {
    description: `Result used when a table is successfully loaded.


The table metadata JSON is returned in the \`metadata\` field. The corresponding file location of table metadata should be returned in the \`metadata-location\` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed.
Clients can check whether metadata has changed by comparing metadata locations after the table has been created.


The \`config\` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.


The following configurations should be respected by clients:

## General Configurations

- \`token\`: Authorization bearer token to use for table requests if OAuth2 security is enabled 

## AWS Configurations

The following configurations should be respected when working with tables stored in AWS S3
 - \`client.region\`: region to configure client for making requests to AWS
 - \`s3.access-key-id\`: id for for credentials that provide access to the data in S3
 - \`s3.secret-access-key\`: secret for credentials that provide access to data in S3 
 - \`s3.session-token\`: if present, this value should be used for as the session token 
 - \`s3.remote-signing-enabled\`: if \`true\` remote signing should be performed as described in the \`s3-signer-open-api.yaml\` specification
`,
    type: 'object',
    required: ['metadata'],
    properties: {
        'metadata-location': {
            type: 'string',
            description: 'May be null if the table is staged as part of a transaction'
        },
        metadata: {
            '$ref': '#/components/schemas/TableMetadata'
        },
        config: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const CommitTableRequestSchema = {
    type: 'object',
    required: ['requirements', 'updates'],
    properties: {
        identifier: {
            description: 'Table identifier to update; must be present for CommitTransactionRequest',
            '$ref': '#/components/schemas/TableIdentifier'
        },
        requirements: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TableRequirement'
            }
        },
        updates: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/TableUpdate'
            }
        }
    }
} as const;

export const CommitViewRequestSchema = {
    type: 'object',
    required: ['updates'],
    properties: {
        identifier: {
            description: 'View identifier to update',
            '$ref': '#/components/schemas/TableIdentifier'
        },
        requirements: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ViewRequirement'
            }
        },
        updates: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ViewUpdate'
            }
        }
    }
} as const;

export const CommitTransactionRequestSchema = {
    type: 'object',
    required: ['table-changes'],
    properties: {
        'table-changes': {
            type: 'array',
            items: {
                description: 'Table commit request; must provide an `identifier`',
                '$ref': '#/components/schemas/CommitTableRequest'
            }
        }
    }
} as const;

export const CreateTableRequestSchema = {
    type: 'object',
    required: ['name', 'schema'],
    properties: {
        name: {
            type: 'string'
        },
        location: {
            type: 'string'
        },
        schema: {
            '$ref': '#/components/schemas/Schema'
        },
        'partition-spec': {
            '$ref': '#/components/schemas/PartitionSpec'
        },
        'write-order': {
            '$ref': '#/components/schemas/SortOrder'
        },
        'stage-create': {
            type: 'boolean'
        },
        properties: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const RegisterTableRequestSchema = {
    type: 'object',
    required: ['name', 'metadata-location'],
    properties: {
        name: {
            type: 'string'
        },
        'metadata-location': {
            type: 'string'
        }
    }
} as const;

export const CreateViewRequestSchema = {
    type: 'object',
    required: ['name', 'schema', 'view-version', 'properties'],
    properties: {
        name: {
            type: 'string'
        },
        location: {
            type: 'string'
        },
        schema: {
            '$ref': '#/components/schemas/Schema'
        },
        'view-version': {
            '$ref': '#/components/schemas/ViewVersion',
            description: 'The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema'
        },
        properties: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const LoadViewResultSchema = {
    description: `Result used when a view is successfully loaded.


The view metadata JSON is returned in the \`metadata\` field. The corresponding file location of view metadata is returned in the \`metadata-location\` field.
Clients can check whether metadata has changed by comparing metadata locations after the view has been created.

The \`config\` map returns view-specific configuration for the view's resources.

The following configurations should be respected by clients:

## General Configurations

- \`token\`: Authorization bearer token to use for view requests if OAuth2 security is enabled
`,
    type: 'object',
    required: ['metadata-location', 'metadata'],
    properties: {
        'metadata-location': {
            type: 'string'
        },
        metadata: {
            '$ref': '#/components/schemas/ViewMetadata'
        },
        config: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const TokenTypeSchema = {
    type: 'string',
    enum: ['urn:ietf:params:oauth:token-type:access_token', 'urn:ietf:params:oauth:token-type:refresh_token', 'urn:ietf:params:oauth:token-type:id_token', 'urn:ietf:params:oauth:token-type:saml1', 'urn:ietf:params:oauth:token-type:saml2', 'urn:ietf:params:oauth:token-type:jwt'],
    description: `Token type identifier, from RFC 8693 Section 3

See https://datatracker.ietf.org/doc/html/rfc8693#section-3`
} as const;

export const OAuthClientCredentialsRequestSchema = {
    description: `OAuth2 client credentials request

See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4`,
    type: 'object',
    required: ['grant_type', 'client_id', 'client_secret'],
    properties: {
        grant_type: {
            type: 'string',
            enum: ['client_credentials']
        },
        scope: {
            type: 'string'
        },
        client_id: {
            type: 'string',
            description: `Client ID

This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.`
        },
        client_secret: {
            type: 'string',
            description: `Client secret

This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.`
        }
    }
} as const;

export const OAuthTokenExchangeRequestSchema = {
    description: `OAuth2 token exchange request

See https://datatracker.ietf.org/doc/html/rfc8693`,
    type: 'object',
    required: ['grant_type', 'subject_token', 'subject_token_type'],
    properties: {
        grant_type: {
            type: 'string',
            enum: ['urn:ietf:params:oauth:grant-type:token-exchange']
        },
        scope: {
            type: 'string'
        },
        requested_token_type: {
            '$ref': '#/components/schemas/TokenType'
        },
        subject_token: {
            type: 'string',
            description: 'Subject token for token exchange request'
        },
        subject_token_type: {
            '$ref': '#/components/schemas/TokenType'
        },
        actor_token: {
            type: 'string',
            description: 'Actor token for token exchange request'
        },
        actor_token_type: {
            '$ref': '#/components/schemas/TokenType'
        }
    }
} as const;

export const OAuthTokenRequestSchema = {
    anyOf: [
        {
            '$ref': '#/components/schemas/OAuthClientCredentialsRequest'
        },
        {
            '$ref': '#/components/schemas/OAuthTokenExchangeRequest'
        }
    ]
} as const;

export const CounterResultSchema = {
    type: 'object',
    required: ['unit', 'value'],
    properties: {
        unit: {
            type: 'string'
        },
        value: {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const TimerResultSchema = {
    type: 'object',
    required: ['time-unit', 'count', 'total-duration'],
    properties: {
        'time-unit': {
            type: 'string'
        },
        count: {
            type: 'integer',
            format: 'int64'
        },
        'total-duration': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const MetricResultSchema = {
    anyOf: [
        {
            '$ref': '#/components/schemas/CounterResult'
        },
        {
            '$ref': '#/components/schemas/TimerResult'
        }
    ]
} as const;

export const MetricsSchema = {
    type: 'object',
    additionalProperties: {
        '$ref': '#/components/schemas/MetricResult'
    },
    example: {
        metrics: {
            'total-planning-duration': {
                count: 1,
                'time-unit': 'nanoseconds',
                'total-duration': 2644235116
            },
            'result-data-files': {
                unit: 'count',
                value: 1
            },
            'result-delete-files': {
                unit: 'count',
                value: 0
            },
            'total-data-manifests': {
                unit: 'count',
                value: 1
            },
            'total-delete-manifests': {
                unit: 'count',
                value: 0
            },
            'scanned-data-manifests': {
                unit: 'count',
                value: 1
            },
            'skipped-data-manifests': {
                unit: 'count',
                value: 0
            },
            'total-file-size-bytes': {
                unit: 'bytes',
                value: 10
            },
            'total-delete-file-size-bytes': {
                unit: 'bytes',
                value: 0
            }
        }
    }
} as const;

export const ReportMetricsRequestSchema = {
    anyOf: [
        {
            '$ref': '#/components/schemas/ScanReport'
        },
        {
            '$ref': '#/components/schemas/CommitReport'
        }
    ],
    required: ['report-type'],
    properties: {
        'report-type': {
            type: 'string'
        }
    }
} as const;

export const ScanReportSchema = {
    type: 'object',
    required: ['table-name', 'snapshot-id', 'filter', 'schema-id', 'projected-field-ids', 'projected-field-names', 'metrics'],
    properties: {
        'table-name': {
            type: 'string'
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        filter: {
            '$ref': '#/components/schemas/Expression'
        },
        'schema-id': {
            type: 'integer'
        },
        'projected-field-ids': {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        'projected-field-names': {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        metrics: {
            '$ref': '#/components/schemas/Metrics'
        },
        metadata: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const CommitReportSchema = {
    type: 'object',
    required: ['table-name', 'snapshot-id', 'sequence-number', 'operation', 'metrics'],
    properties: {
        'table-name': {
            type: 'string'
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'sequence-number': {
            type: 'integer',
            format: 'int64'
        },
        operation: {
            type: 'string'
        },
        metrics: {
            '$ref': '#/components/schemas/Metrics'
        },
        metadata: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        }
    }
} as const;

export const OAuthErrorSchema = {
    type: 'object',
    required: ['error'],
    properties: {
        error: {
            type: 'string',
            enum: ['invalid_request', 'invalid_client', 'invalid_grant', 'unauthorized_client', 'unsupported_grant_type', 'invalid_scope']
        },
        error_description: {
            type: 'string'
        },
        error_uri: {
            type: 'string'
        }
    }
} as const;

export const OAuthTokenResponseSchema = {
    type: 'object',
    required: ['access_token', 'token_type'],
    properties: {
        access_token: {
            type: 'string',
            description: 'The access token, for client credentials or token exchange'
        },
        token_type: {
            type: 'string',
            enum: ['bearer', 'mac', 'N_A'],
            description: `Access token type for client credentials or token exchange

See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1`
        },
        expires_in: {
            type: 'integer',
            description: 'Lifetime of the access token in seconds for client credentials or token exchange'
        },
        issued_token_type: {
            '$ref': '#/components/schemas/TokenType'
        },
        refresh_token: {
            type: 'string',
            description: 'Refresh token for client credentials or token exchange'
        },
        scope: {
            type: 'string',
            description: 'Authorization scope for client credentials or token exchange'
        }
    }
} as const;

export const IcebergErrorResponseSchema = {
    description: 'JSON wrapper for all error responses (non-2xx)',
    type: 'object',
    required: ['error'],
    properties: {
        error: {
            '$ref': '#/components/schemas/ErrorModel'
        }
    },
    additionalProperties: false,
    example: {
        error: {
            message: 'The server does not support this operation',
            type: 'UnsupportedOperationException',
            code: 406
        }
    }
} as const;

export const CreateNamespaceResponseSchema = {
    type: 'object',
    required: ['namespace'],
    properties: {
        namespace: {
            '$ref': '#/components/schemas/Namespace'
        },
        properties: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            },
            description: 'Properties stored on the namespace, if supported by the server.',
            example: {
                owner: 'Ralph',
                created_at: '1452120468'
            },
            default: {}
        }
    }
} as const;

export const GetNamespaceResponseSchema = {
    type: 'object',
    required: ['namespace'],
    properties: {
        namespace: {
            '$ref': '#/components/schemas/Namespace'
        },
        properties: {
            type: 'object',
            description: 'Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.',
            additionalProperties: {
                type: 'string'
            },
            example: {
                owner: 'Ralph',
                transient_lastDdlTime: '1452120468'
            },
            default: {},
            nullable: true
        },
        'namespace-uuid': {
            type: 'string',
            nullable: true
        }
    }
} as const;

export const ListTablesResponseSchema = {
    type: 'object',
    properties: {
        'next-page-token': {
            '$ref': '#/components/schemas/PageToken'
        },
        identifiers: {
            type: 'array',
            uniqueItems: true,
            items: {
                '$ref': '#/components/schemas/TableIdentifier'
            }
        },
        'table-uuids': {
            type: 'array',
            uniqueItems: true,
            nullable: true,
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const ListNamespacesResponseSchema = {
    type: 'object',
    properties: {
        'next-page-token': {
            '$ref': '#/components/schemas/PageToken'
        },
        namespaces: {
            type: 'array',
            uniqueItems: true,
            items: {
                '$ref': '#/components/schemas/Namespace'
            }
        },
        'namespace-uuids': {
            type: 'array',
            uniqueItems: true,
            nullable: true,
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const UpdateNamespacePropertiesResponseSchema = {
    type: 'object',
    required: ['updated', 'removed'],
    properties: {
        updated: {
            description: 'List of property keys that were added or updated',
            type: 'array',
            uniqueItems: true,
            items: {
                type: 'string'
            }
        },
        removed: {
            description: 'List of properties that were removed',
            type: 'array',
            items: {
                type: 'string'
            }
        },
        missing: {
            type: 'array',
            items: {
                type: 'string'
            },
            description: "List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.",
            nullable: true
        }
    }
} as const;

export const CommitTableResponseSchema = {
    type: 'object',
    required: ['metadata-location', 'metadata'],
    properties: {
        'metadata-location': {
            type: 'string'
        },
        metadata: {
            '$ref': '#/components/schemas/TableMetadata'
        }
    }
} as const;

export const StatisticsFileSchema = {
    type: 'object',
    required: ['snapshot-id', 'statistics-path', 'file-size-in-bytes', 'file-footer-size-in-bytes', 'blob-metadata'],
    properties: {
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'statistics-path': {
            type: 'string'
        },
        'file-size-in-bytes': {
            type: 'integer',
            format: 'int64'
        },
        'file-footer-size-in-bytes': {
            type: 'integer',
            format: 'int64'
        },
        'blob-metadata': {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/BlobMetadata'
            }
        }
    }
} as const;

export const BlobMetadataSchema = {
    type: 'object',
    required: ['type', 'snapshot-id', 'sequence-number', 'fields'],
    properties: {
        type: {
            type: 'string'
        },
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'sequence-number': {
            type: 'integer',
            format: 'int64'
        },
        fields: {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        properties: {
            type: 'object'
        }
    }
} as const;

export const PartitionStatisticsFileSchema = {
    type: 'object',
    required: ['snapshot-id', 'statistics-path', 'file-size-in-bytes'],
    properties: {
        'snapshot-id': {
            type: 'integer',
            format: 'int64'
        },
        'statistics-path': {
            type: 'string'
        },
        'file-size-in-bytes': {
            type: 'integer',
            format: 'int64'
        }
    }
} as const;

export const BooleanTypeValueSchema = {
    type: 'boolean',
    example: true
} as const;

export const IntegerTypeValueSchema = {
    type: 'integer',
    example: 42
} as const;

export const LongTypeValueSchema = {
    type: 'integer',
    format: 'int64',
    example: 9223372036854776000
} as const;

export const FloatTypeValueSchema = {
    type: 'number',
    format: 'float',
    example: 3.14
} as const;

export const DoubleTypeValueSchema = {
    type: 'number',
    format: 'double',
    example: 123.456
} as const;

export const DecimalTypeValueSchema = {
    type: 'string',
    description: "Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain text, while decimals with a negative scale use scientific notation and the exponent will be equal to the negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2', and with a negative scale is '2E+20'",
    example: '123.4500'
} as const;

export const StringTypeValueSchema = {
    type: 'string',
    example: 'hello'
} as const;

export const UUIDTypeValueSchema = {
    type: 'string',
    format: 'uuid',
    pattern: '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',
    maxLength: 36,
    minLength: 36,
    description: 'UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified by RFC-4122',
    example: 'eb26bdb1-a1d8-4aa6-990e-da940875492c'
} as const;

export const DateTypeValueSchema = {
    type: 'string',
    format: 'date',
    description: "Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format",
    example: '2007-12-03'
} as const;

export const TimeTypeValueSchema = {
    type: 'string',
    description: "Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision",
    example: '22:31:08.123456'
} as const;

export const TimestampTypeValueSchema = {
    type: 'string',
    description: "Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision",
    example: '2007-12-03T10:15:30.123456'
} as const;

export const TimestampTzTypeValueSchema = {
    type: 'string',
    description: "TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision, and a timezone offset (+00:00 for UTC)",
    example: '2007-12-03T10:15:30.123456+00:00'
} as const;

export const TimestampNanoTypeValueSchema = {
    type: 'string',
    description: "Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision",
    example: '2007-12-03T10:15:30.123456789'
} as const;

export const TimestampTzNanoTypeValueSchema = {
    type: 'string',
    description: "Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond precision, and a timezone offset (+00:00 for UTC)",
    example: '2007-12-03T10:15:30.123456789+00:00'
} as const;

export const FixedTypeValueSchema = {
    type: 'string',
    description: 'Fixed length type values are stored and serialized as an uppercase hexadecimal string preserving the fixed length',
    example: '78797A'
} as const;

export const BinaryTypeValueSchema = {
    type: 'string',
    description: 'Binary type values are stored and serialized as an uppercase hexadecimal string',
    example: '78797A'
} as const;

export const CountMapSchema = {
    type: 'object',
    properties: {
        keys: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/IntegerTypeValue'
            },
            description: 'List of integer column ids for each corresponding value'
        },
        values: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/LongTypeValue'
            },
            description: "List of Long values, matched to 'keys' by index"
        }
    },
    example: {
        keys: [1, 2],
        values: [100, 200]
    }
} as const;

export const ValueMapSchema = {
    type: 'object',
    properties: {
        keys: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/IntegerTypeValue'
            },
            description: 'List of integer column ids for each corresponding value'
        },
        values: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/PrimitiveTypeValue'
            },
            description: "List of primitive type values, matched to 'keys' by index"
        }
    },
    example: {
        keys: [1, 2],
        values: [100, 'test']
    }
} as const;

export const PrimitiveTypeValueSchema = {
    oneOf: [
        {
            '$ref': '#/components/schemas/BooleanTypeValue'
        },
        {
            '$ref': '#/components/schemas/IntegerTypeValue'
        },
        {
            '$ref': '#/components/schemas/LongTypeValue'
        },
        {
            '$ref': '#/components/schemas/FloatTypeValue'
        },
        {
            '$ref': '#/components/schemas/DoubleTypeValue'
        },
        {
            '$ref': '#/components/schemas/DecimalTypeValue'
        },
        {
            '$ref': '#/components/schemas/StringTypeValue'
        },
        {
            '$ref': '#/components/schemas/UUIDTypeValue'
        },
        {
            '$ref': '#/components/schemas/DateTypeValue'
        },
        {
            '$ref': '#/components/schemas/TimeTypeValue'
        },
        {
            '$ref': '#/components/schemas/TimestampTypeValue'
        },
        {
            '$ref': '#/components/schemas/TimestampTzTypeValue'
        },
        {
            '$ref': '#/components/schemas/TimestampNanoTypeValue'
        },
        {
            '$ref': '#/components/schemas/TimestampTzNanoTypeValue'
        },
        {
            '$ref': '#/components/schemas/FixedTypeValue'
        },
        {
            '$ref': '#/components/schemas/BinaryTypeValue'
        }
    ]
} as const;

export const FileFormatSchema = {
    type: 'string',
    enum: ['avro', 'orc', 'parquet']
} as const;

export const ContentFileSchema = {
    discriminator: {
        propertyName: 'content',
        mapping: {
            data: '#/components/schemas/DataFile',
            'position-deletes': '#/components/schemas/PositionDeleteFile',
            'equality-deletes': '#/components/schemas/EqualityDeleteFile'
        }
    },
    type: 'object',
    required: ['spec-id', 'content', 'file-path', 'file-format', 'file-size-in-bytes', 'record-count'],
    properties: {
        content: {
            type: 'string'
        },
        'file-path': {
            type: 'string'
        },
        'file-format': {
            '$ref': '#/components/schemas/FileFormat'
        },
        'spec-id': {
            type: 'integer'
        },
        partition: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/PrimitiveTypeValue'
            },
            description: 'A list of partition field values ordered based on the fields of the partition spec specified by the `spec-id`',
            example: [1, 'bar']
        },
        'file-size-in-bytes': {
            type: 'integer',
            format: 'int64',
            description: 'Total file size in bytes'
        },
        'record-count': {
            type: 'integer',
            format: 'int64',
            description: 'Number of records in the file'
        },
        'key-metadata': {
            allOf: [
                {
                    '$ref': '#/components/schemas/BinaryTypeValue'
                }
            ],
            description: 'Encryption key metadata blob'
        },
        'split-offsets': {
            type: 'array',
            items: {
                type: 'integer',
                format: 'int64'
            },
            description: 'List of splittable offsets'
        },
        'sort-order-id': {
            type: 'integer'
        }
    }
} as const;

export const DataFileSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/ContentFile'
        }
    ],
    type: 'object',
    required: ['content'],
    properties: {
        content: {
            type: 'string',
            enum: ['data']
        },
        'column-sizes': {
            allOf: [
                {
                    '$ref': '#/components/schemas/CountMap'
                }
            ],
            description: 'Map of column id to total count, including null and NaN'
        },
        'value-counts': {
            allOf: [
                {
                    '$ref': '#/components/schemas/CountMap'
                }
            ],
            description: 'Map of column id to null value count'
        },
        'null-value-counts': {
            allOf: [
                {
                    '$ref': '#/components/schemas/CountMap'
                }
            ],
            description: 'Map of column id to null value count'
        },
        'nan-value-counts': {
            allOf: [
                {
                    '$ref': '#/components/schemas/CountMap'
                }
            ],
            description: 'Map of column id to number of NaN values in the column'
        },
        'lower-bounds': {
            allOf: [
                {
                    '$ref': '#/components/schemas/ValueMap'
                }
            ],
            description: 'Map of column id to lower bound primitive type values'
        },
        'upper-bounds': {
            allOf: [
                {
                    '$ref': '#/components/schemas/ValueMap'
                }
            ],
            description: 'Map of column id to upper bound primitive type values'
        }
    }
} as const;

export const PositionDeleteFileSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/ContentFile'
        }
    ],
    required: ['content'],
    properties: {
        content: {
            type: 'string',
            enum: ['position-deletes']
        }
    }
} as const;

export const EqualityDeleteFileSchema = {
    allOf: [
        {
            '$ref': '#/components/schemas/ContentFile'
        }
    ],
    required: ['content'],
    properties: {
        content: {
            type: 'string',
            enum: ['equality-deletes']
        },
        'equality-ids': {
            type: 'array',
            items: {
                type: 'integer'
            },
            description: 'List of equality field IDs'
        }
    }
} as const;